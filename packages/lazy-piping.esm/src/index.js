function n(n){var t;return Array.isArray(n)||"function"==typeof(null===(t=n)||void 0===t?void 0:t[Symbol.iterator])}function t(n){var t;return"function"==typeof(null===(t=n)||void 0===t?void 0:t[Symbol.asyncIterator])}function*o(n=0,t=1/0,o=1){let r=n,i=t;for(;i>0;)yield r,r+=o,i-=o}class r{constructor(t,o={}){if(this._callbackList=[],!n(t))throw new TypeError("The given input is not a valid iterable.");this._iter=t}*_calc(){let n=this._iter;for(const t of this._callbackList){const o=t(n),r=[];for(const t of n)r.push(yield*o);n=r.values()}return n}pipe(...n){return this._callbackList=null!=n?n:[],this}get(n){const t=Array.from(this._calc());return"function"==typeof n?n(t):t}}function i(n,t){return new r(n,t)}function f(n){return function*(t){for(const o of t)yield n(o)}}function e(n){return function*(t){for(const o of t)n(o),yield o}}function c(n){return function*(t){for(const o of t)n(o)&&(yield o)}}function u(n){return function*(t){for(const o of t)if(n(o))return void(yield o)}}function l(n){return function*(t){for(const n of t)yield n;for(const t of n)yield t}}function s(){return function*(n){const t=new Set;for(const o of n)t.has(o)||(t.add(o),yield o);t.clear()}}function a(n=0,t=1/0){return function*(o){for(const r of o)if(!(0>n)){if(0>=t)return;yield r}}}function y(n=1/0){return function*(t){for(const o of t){if(0>n)return;yield o}}}function d(){return function*(n){yield n.next().value}}export{r as LazyPiping,l as concat,c as filter,u as find,d as first,i as from,t as isAsyncIterable,n as isIterable,f as map,o as range,e as skim,a as slice,y as take,s as unique};
